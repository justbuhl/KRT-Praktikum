\documentclass{ifacconf}

\usepackage{natbib}            % you should have natbib.sty
\usepackage[utf8]{inputenc}    % Eingabe von Umlauten im Editor, dieser sollte dann auch auf utf8 Encoding eingestellt sein
\usepackage{graphicx}          % Include this line if your 
                               % document contains figures,
%\usepackage[dvips]{epsfig}    % or this line, depending on which
                               % you prefer.
                               
\usepackage{units}

% for German
% \usepackage{ngerman}           % neue Deutsche Rechtschreibung, Silbentrennung
% \usepackage[T1]{fontenc}       % Trennung mit Umlauten

% to include tikz pictures of figure created with matlab2tikz, see also file ``plotFigureTest.m''
\usepackage{tikz}
\usepackage{pgfplots}
\pgfplotsset{compat=newest}  % use newest version of pgfplots
\usepackage{float}
\usepackage{amsmath}  % useful for math

% to include the legend into the caption. The commands are
%\mlLineLegend{red}
%\mlLineLegendDashed{red}
%\mlLineLegendDotted{red}
%\mlLineLegendDashDotted{red}
%\mlPointLegend{red}
\newlength{\mlLegendThickness}
\setlength{\mlLegendThickness}{0.4mm}
\newlength{\mlLegendHeight}
\setlength{\mlLegendHeight}{0.6ex}
\newcommand{\mlLineLegend}[1]{\mbox{\color{#1}
\protect\rule[\mlLegendHeight]{3mm}{\mlLegendThickness}\hspace*{-1mm}
}}
\newcommand{\mlLineLegendDashed}[1]{\mbox{\color{#1}
\protect\rule[\mlLegendHeight]{1.5mm}{\mlLegendThickness}\hspace*{0mm}
\protect\rule[\mlLegendHeight]{1.5mm}{\mlLegendThickness}\hspace*{-1mm}
}}
\newcommand{\mlLineLegendDotted}[1]{\mbox{\color{#1}
\protect\rule[\mlLegendHeight]{0.4mm}{\mlLegendThickness}\hspace*{0mm}
\protect\rule[\mlLegendHeight]{0.4mm}{\mlLegendThickness}\hspace*{0mm}
\protect\rule[\mlLegendHeight]{0.4mm}{\mlLegendThickness}\hspace*{0mm}
\protect\rule[\mlLegendHeight]{0.4mm}{\mlLegendThickness}\hspace*{-1mm}
}}
\newcommand{\mlLineLegendDashDotted}[1]{\mbox{\color{#1}
\protect\rule[\mlLegendHeight]{1.5mm}{\mlLegendThickness}\hspace*{0mm}
\protect\rule[\mlLegendHeight]{0.4mm}{\mlLegendThickness}\hspace*{0mm}
\protect\rule[\mlLegendHeight]{1.5mm}{\mlLegendThickness}\hspace*{0mm}
\protect\rule[\mlLegendHeight]{0.4mm}{\mlLegendThickness}\hspace*{-1mm}
}}
\newcommand{\mlPointLegend}[1]{\mbox{\color{#1}
\protect\rule[\mlLegendHeight]{0.4mm}{\mlLegendThickness}\hspace*{-0.75mm}
}}

\begin{document}

\begin{frontmatter}

\title{KRT Praktikum: Protokoll 3 - L3 und H3}

\thanks[footnoteinfo]{Institute for Systems Theory and Automatic Control, University of Stuttgart, Germany. \textit{http://www.ist.uni-stuttgart.de}}

% include all authors, underline corresponding author
\author{Kimon Beyer, Yves Gaßmann, Justin Buhl} 
% \author{}

\begin{abstract}        
Im folgenden Protokoll werden die Ergebnisse des dritten Labortages sowie der dritten Hausaufgabe im Rahmen des Praktikums Konzepte der Regelungstechnik des IST behandelt. 
Dabei behandelt das Protokoll die Ausarbeitung und Validierung eines Reglerentwurfs für das aus Protokoll 2 extrahierte Helikoptermodell 
sowie dessen simulative und erste praktische Validierung.                     % Abstract of not more than 250 words.
\end{abstract}

\end{frontmatter}


\section{Dritter Labortag (L3)}
Für den folgenden Reglerentwurf wird das aus Protokoll 2 gewonnene lineare Helikoptermodell genutzt. Wichtig ist hierbei zu beachten,
dass der Reglerentwurf auf dem linearen Modell basiert und somit bei der Implementierung auf das nichtlineare Modell noch der 
Arbeitspunkt bzw. Linearisierungspunkt entsprechend verrechnet werden muss. 
Die Zustände sind zur Erinnerung wie folgt definiert:
\begin{equation}
    x = \begin{bmatrix} \alpha & \beta & \gamma & \dot{\alpha} & \dot{\beta} & \dot{\gamma} \end{bmatrix}^T
\end{equation}
\begin{equation}
    u = \begin{bmatrix} U_{\mathrm{vorne}} & U_{\mathrm{hinten}} \end{bmatrix}^T
\end{equation}
\begin{equation}
    y = \begin{bmatrix} \alpha & \beta & \gamma \end{bmatrix}^T
\end{equation}

Für den geschlossenen Regelkreis ergibt sich dann mit Regler unter Berücksichtigung des Arbeitspunktes: 
\begin{equation}
\Delta u = -K\,\Delta x,\qquad \Delta x = x - x_0 ,\qquad \Delta u = u - u_0
\end{equation}
wobei $x_0$ und $u_0$ die Arbeitspunkte sind. Die resultierenden geschlossenen Regelkreise werden in den folgenden Abschnitte noch 
dargestellt.

Zur Implementierung und Erprobung unseres Regelungsentwurfs wurde nun das CAD-Modell, 
das bereits zur Modellierung verwendet wurde, in 
Matlab Simulink exportiert. Dies hat den Vorteil, dass das Modell möglichst nah an den realen Versuchsstand angenähert wird, wodurch
eine realistischere Simulation des Systemverhaltens ermöglicht wird. Des Weiteren ist es möglich, innerhalb desselben Simulink-Modells zwischen
dem Modell und der realen Anlage umzuschalten, wodurch eine schnelle Validierung des Reglerentwurfs an der realen Anlage ermöglicht wird.

\begin{figure}[h!]
    \centering
    % Begrenze Breite und Höhe, behalte Seitenverhältnis bei, sodass das ganze Bild sichtbar und nicht zu groß ist
    \includegraphics[width=0.5\textwidth,height=0.6\textheight,keepaspectratio]{modell_simulink.png} % Pfad und Dateiname anpassen
    \caption{Nichtlineares CAD Modell zur Simulation in Simulink.}
    \label{fig:helicopter_cad}
\end{figure}

\subsection{Reglerentwurf}

Im Wesentlichen bestehen zwei mögliche Reglerentwurfsverfahren: Regler im Frequenzbereich und Regler im Zustandsraum. 
Da es sich um ein MIMO-System handelt, 
ist ein Reglerentwurf mittels Loopshaping im Frequenzbereich aufwändig und mit schwierigen Stabilitäts- und Gütenachweisen verbunden. Da das System
außerdem bereits im Zustandsraum entwickelt worden ist, gestaltet sich ein Reglerentwurf im Zustandsraum als die bessere Alternative. 
Hier besteht vor allem die Möglichkeit des LQR-Reglerentwurfs. Durch Matlab-Funktionen und das Lösen der Riccati-Gleichungen
wird die optimale stabilisierende Zustandsrückführung berechnet. Zu beachten ist jedoch, dass durch die Nutzung eines Beobachters die garantierten
Robustheitseigenschaften des LQR nicht mehr gegeben sind. 

Da für die Regelung ebenfalls die Winkelgeschwindigkeiten $\dot{\alpha}$, $\dot{\beta}$ und $\dot{\gamma}$ benötigt werden, der Winkel-Encoder 
jedoch nur die Winkel $\alpha$, $\beta$ und $\gamma$ misst, müssen die Geschwindigkeiten geschätzt werden. 
Dies realisieren wir durch einen Luenberger-Beobachter: 

\begin{equation}
\Delta\dot{\hat{x}} = A\,\Delta\hat{x} + B\,\Delta\hat{u} + L\big(\Delta y - \Delta\hat{y}\big),
\end{equation}
mit
\begin{equation}
\Delta\hat{y} = C\,\Delta\hat{x},
\end{equation}
und der Schätzfehler $\hat{e}=\Delta x-\Delta\hat{x}$ erfüllt
\begin{equation}
\dot{\hat{e}}=(A-LC)\,\hat{e}.
\end{equation}

Zur Stabilität und schnellen Konvergenz wählt man die Beobachterpole (Eigenwerte von $A-LC$) deutlich schneller als die Reglerpole (z.\,B. Faktor 5–10). Die Gewinnmatrix $L$ wird in MATLAB durch Polvorgabe bestimmt.

\subsubsection{Anforderungen an den geschlossenen Kreis bzw. Regler}
Gesucht wird selbstverständlich ein stabilisierender Regler, der die gegebenen Modellunsicherheiten möglichst gut kompensiert. 
Die Performance muss dabei ausreichend gut sein, um die vorgegebene Zeit einzuhalten. Dennoch überwiegt die Anforderung an die Robustheit des Reglers.
Denn durch die relativ stark vereinfachte Modellbildung und die gegebenen Beschränkungen für den finalen Flug müssen unter den bestehenden Unsicherheiten
die Beschränkungen in jedem Fall eingehalten werden. Damit die gegebenen Beschränkungen auch eingehalten werden, ist neben der robusten Stabilität die Vermeidung einer 
bleibenden Regelabweichung als wichtigstes Entwurfsziel anzusehen. Denn eine bleibende Regelabweichung könnte schnell zum Verletzen der Beschränkungen führen, z.\,B. bei 
der Einhaltung der Mindesthöhe. Die Stabilität ist im Zustandsraum einfach nachzuweisen durch Berechnung der 
Systempole des geschlossenen Regelkreises. Die Eliminierung einer bleibenden Regelabweichung kann durch Hinzufügen eines bzw. mehrerer Integratorzustände erreicht werden. 
Aussagen über Performance oder Robustheit gestalten sich jedoch schwierig. Analytische Nachweise über Robustheit oder Performance gestalten sich als sehr aufwändig,
z.\,B. durch Entwicklung einer M-$\Delta$-Struktur und Überprüfung der Systemnorm gegenüber bestimmten unstrukturierten $\Delta$-Unsicherheiten. Dies ist jedoch
sehr aufwändig und zunächst fehleranfällig, wodurch nur die simulative Validierung sowie die Validierung am realen Teststand als realisierbare Möglichkeiten übrig bleiben.

\subsubsection{LQR-Entwurf}
Im Verlauf des Protokolls wurde bereits vorweggenommen, dass sich für einen LQR-Reglerentwurf entschieden worden ist. 
Der Vorteil besteht in der vergleichsweise einfachen Implementierung sowie den guten Regelungseigenschaften. Die garantierten
Robustheitseigenschaften sind, wie bereits erwähnt, durch die Nutzung eines Beobachters nicht mehr gegeben. 

Für den Entwurf eines LQR-Reglers müssen lediglich die Gewichtungsmatrizen $Q$ und $R$ festgelegt werden. Diese Matrizen bestimmen das Verhalten des Reglers und müssen sorgfältig ausgewählt werden, um die gewünschten Regelungsziele zu erreichen.
Die Matrizen müssen simulativ bzw. experimentell abgestimmt werden. Bei Erprobungsversuchen am realen Teststand hat sich jedoch 
eine signifikante Regelabweichung gezeigt. Dadurch ist schnell ersichtlich geworden, dass eine Erweiterung zu einem LQI-Regler notwendig ist, 
um die erforderlichen Regelungsziele zu erreichen. Daher wird im Folgenden der LQI-Regler betrachtet, da dieser lediglich eine 
Erweiterung des LQR-Reglers darstellt. 

\subsubsection{LQI-Entwurf}
Wie bereits erwähnt, stellt der LQI-Regler eine Erweiterung des LQR-Reglers dar. Die Erweiterung geschieht hierbei durch 
Hinzunahme von sogenannten Integratorzuständen für diejenigen Größen, für die die bleibende Regelabweichung eliminiert werden soll. Zu beachten ist jedoch,
dass durch die Nutzung von Integratoren auf jeden Fall darauf geachtet werden muss, ein Aufschwingen des Integrators zu vermeiden und gegebenenfalls einen Anti-Windup zu implementieren.
Dadurch ergibt sich ein erweiterter Zustandsraum, der wie folgt aussieht:
\begin{equation}
    x = \begin{bmatrix} \alpha & \beta & \gamma & \dot{\alpha} & \dot{\beta} & \dot{\gamma} & \xi_1 & \xi_2 \end{bmatrix}^T
\end{equation}

wobei $\xi_1$ und $\xi_2$ die Integratorzustände für die Winkel $\alpha$ und $\beta$ darstellen und folgendermaßen im Zustandsraum gebildet werden:

\begin{equation}
    \xi_1 = \xi_{1,\mathrm{ref}} - \int (\alpha_{\mathrm{ref}} - \alpha)\,\mathrm{d}t
\end{equation}
\begin{equation}
    \xi_2 = \xi_{2,\mathrm{ref}} - \int (\beta_{\mathrm{ref}} - \beta)\,\mathrm{d}t
\end{equation}

wobei $\xi_{1,\mathrm{ref}} = 0$ und $\xi_{2,\mathrm{ref}} = 0$.

Für die Wahl der Gewichtungsmatrizen $Q$ und $R$ hat sich zunächst folgende Wahl, durch experimentelle Abstimmung am realen 
Versuchsstand ergeben: 

\begin{equation}
\begin{split}
Q = \operatorname{diag}\big(&50,\;5,\;0,001,\;0,001,\\
&0,001,\;0,001,\;10,\;10\big)
\end{split}
\end{equation}
\begin{equation}
R = \operatorname{diag}\big(10,\;10\big)
\end{equation}

Mit der Wahl dieser Gewichtungsmatrizen ergeben sich folgende Regler und Beobachtungspole: 

\begin{equation}
\text{Reglerpole} = 
\begin{bmatrix}
-0.4472 + 0.0000\mathrm{i}\\
-0.5246 + 0.8358\mathrm{i}\\
-0.5246 - 0.8358\mathrm{i}\\
-0.5625 + 1.3857\mathrm{i}\\
-0.5625 - 1.3857\mathrm{i}\\
-0.8454 + 0.0000\mathrm{i}\\
-1.3553 + 0.5754\mathrm{i}\\
-1.3553 - 0.5754\mathrm{i}
\end{bmatrix}
\end{equation}

\begin{equation}
\text{Beobachterpole} =
\begin{bmatrix}
-60 + 0.0000\mathrm{i}\\
-61 + 0.0000\mathrm{i}\\
-62 + 0.0000\mathrm{i}\\
-63 + 0.0000\mathrm{i}\\
-64 + 0.0000\mathrm{i}\\
-65 + 0.0000\mathrm{i}
\end{bmatrix}
\end{equation}

Die Wahl der Pole kann sich jedoch noch ändern. Es ist bekannt, dass zu schnelle Beobachterpole ebenfalls zu Problemen führen können.

\subsubsection{Reglerimplementierung}
Im Folgenden wird nun die Implementierung des LQI-Reglers im Simulink-Modell beschrieben.
In Abbildung \ref{fig:simulink_overview} ist das Gesamtsystem dargestellt. In Abbildung~\ref{fig:simulink_controler} ist der Reglerblock dargestellt. Hier ist 
ebenfalls die Implementierung des Anti-Windups zu sehen. In Abbildung~\ref{fig:simulink_observer} ist der Beobachterblock dargestellt.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.85\linewidth,keepaspectratio]{simulink_overview.png}
    \caption{Übersicht: Simulink-Implementierung des Gesamtsystems.}
    \label{fig:simulink_overview}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.85\linewidth,keepaspectratio]{controler.png}
    \caption{Übersicht: Simulink-Implementierung des Reglers.}
    \label{fig:simulink_controler}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.85\linewidth,keepaspectratio]{observer.png}
    \caption{Übersicht: Simulink-Implementierung des Beobachters.}
    \label{fig:simulink_observer}
\end{figure}

\subsection{Simulationsergebnisse}

Zunächst wurde der LQR-Regler simulativ validiert. Die Simulation zeigte, dass der Regler das gewünschte Regelverhalten aufweist und
die geforderten Spezifikationen erfüllt. Aufgrund der positiven Simulationsergebnisse wurde anschließend direkt zur Validierung an der realen
Anlage übergegangen. Dabei mussten die Gewichtungen in der Matrix $R$ angepasst werden, um ein optimales Regelverhalten zu erzielen.

\subsection{Praktische Validierung}

Aufgrund unseres schnellen Vorankommens war es uns möglich, den Reglerentwurf direkt an der realen Anlage zu validieren. Nachdem, wie bereits 
beschrieben, der LQR-Ansatz simulativ validiert wurde, wurde der LQR auch an der realen Anlage implementiert und validiert. Im Anschluss 
folgte die Erweiterung auf den LQI-Regler, welcher ebenfalls direkt an der realen Anlage implementiert und validiert wurde. 
Der LQI-Regler zeichnete sich unmittelbar durch die Eliminierung der bleibenden Regelabweichung aus. Auch erste Referenzpunktwechsel
wurden durchgeführt, welche der Regler ausgesprochen gut bewältigte. Die Referenzpunktwechsel wurden durch Sprünge in den Referenzwerten 
durchgeführt, was die denkbar schlechteste Vorgehensweise darstellt. Im weiteren Verlauf wird nun noch eine Referenzwertsteuerung mittels
Trajektorienplanung oder ähnlicher Verfahren implementiert. 

\section{Dritte Hausaufgabe (H3)}
Aus dem vorangegangenen Protokoll wird ersichtlich, dass das entwickelte Reglerentwurfsverfahren bereits ausgiebig durchdacht und 
an der realen Anlage validiert worden ist. Daher ergab sich für die dritte Hausaufgabe kein weiterer Aufwand, 
da wir die Aufgaben bereits größtenteils erledigt hatten. Die Validierung an der realen Anlage zeigte, dass die 
definierten Regelungsziele zu unserer Zufriedenheit erfüllt worden sind. Das extrahierte Modell ist ausreichend genau 
und liefert mittels LQI-Regler eine zufriedenstellende Performance sowie zumindest experimentell nachgewiesene Robustheit.

\section{Kommentare und Ausblick auf L4}
Es existiert bereits ein gut funktionierender Regler, der nun nur noch um eine Vorsteuerung und Trajektoriengenerierung für die finale Flugaufgabe erweitert werden muss. 
Für den nächsten Labortag wurden bereits Konzepte entwickelt, wie die Trajektorienplanung und -verfolgung weiter verbessert werden können. 
Diese sollen in L4 umgesetzt und getestet werden. 

\end{document}


