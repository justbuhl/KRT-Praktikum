\documentclass{ifacconf}

\usepackage{natbib}            % you should have natbib.sty
\usepackage[utf8]{inputenc}    % Eingabe von Umlauten im Editor, dieser sollte dann auch auf utf8 Encoding eingestellt sein
\usepackage{graphicx}          % Include this line if your 
                               % document contains figures,
%\usepackage[dvips]{epsfig}    % or this line, depending on which
                               % you prefer.
                               
\usepackage{units}

% for German
% \usepackage{ngerman}           % neue Deutsche Rechtschreibung, Silbentrennung
% \usepackage[T1]{fontenc}       % Trennung mit Umlauten

% to include tikz pictures of figure created with matlab2tikz, see also file ``plotFigureTest.m''
\usepackage{tikz}
\usepackage{pgfplots}
\pgfplotsset{compat=newest}  % use newest version of pgfplots
\usepackage{amsmath}  % useful for math

% to include the legend into the caption. The commands are
%\mlLineLegend{red}
%\mlLineLegendDashed{red}
%\mlLineLegendDotted{red}
%\mlLineLegendDashDotted{red}
%\mlPointLegend{red}
\newlength{\mlLegendThickness}
\setlength{\mlLegendThickness}{0.4mm}
\newlength{\mlLegendHeight}
\setlength{\mlLegendHeight}{0.6ex}
\newcommand{\mlLineLegend}[1]{\mbox{\color{#1}
\protect\rule[\mlLegendHeight]{3mm}{\mlLegendThickness}\hspace*{-1mm}
}}
\newcommand{\mlLineLegendDashed}[1]{\mbox{\color{#1}
\protect\rule[\mlLegendHeight]{1.5mm}{\mlLegendThickness}\hspace*{0mm}
\protect\rule[\mlLegendHeight]{1.5mm}{\mlLegendThickness}\hspace*{-1mm}
}}
\newcommand{\mlLineLegendDotted}[1]{\mbox{\color{#1}
\protect\rule[\mlLegendHeight]{0.4mm}{\mlLegendThickness}\hspace*{0mm}
\protect\rule[\mlLegendHeight]{0.4mm}{\mlLegendThickness}\hspace*{0mm}
\protect\rule[\mlLegendHeight]{0.4mm}{\mlLegendThickness}\hspace*{0mm}
\protect\rule[\mlLegendHeight]{0.4mm}{\mlLegendThickness}\hspace*{-1mm}
}}
\newcommand{\mlLineLegendDashDotted}[1]{\mbox{\color{#1}
\protect\rule[\mlLegendHeight]{1.5mm}{\mlLegendThickness}\hspace*{0mm}
\protect\rule[\mlLegendHeight]{0.4mm}{\mlLegendThickness}\hspace*{0mm}
\protect\rule[\mlLegendHeight]{1.5mm}{\mlLegendThickness}\hspace*{0mm}
\protect\rule[\mlLegendHeight]{0.4mm}{\mlLegendThickness}\hspace*{-1mm}
}}
\newcommand{\mlPointLegend}[1]{\mbox{\color{#1}
\protect\rule[\mlLegendHeight]{0.4mm}{\mlLegendThickness}\hspace*{-0.75mm}
}}

\begin{document}

\begin{frontmatter}

\title{KRT Praktikum: Protokoll 2 - L2 und H2}

\thanks[footnoteinfo]{Institute for Systems Theory and Automatic Control, University of Stuttgart, Germany. \textit{http://www.ist.uni-stuttgart.de}}

% include all authors, underline corresponding author
\author{Kimon Beyer, Yves Gaßmann, Justin Buhl} 
% \author{}

\begin{abstract}        
Im folgenden Protokoll werden die Ergebnisse des zweiten Labortages sowie der zweiten Hausaufgabe im Ramen des Praktikums Konzepte der Regelungstechnik des IST behandelt. 
Dabei erfolgte die aus dem Protokoll 1 gewonnene Identifikation der fehlenden Modellparameter zur vollständigen Beschreibung des Helikopter Modells. Des Weiteren wurde 
nun dieses Modell simulativ validiert, sowie linearisiert.                       % Abstract of not more than 250 words.
\end{abstract}

\end{frontmatter}


\section{Zweiter Labortag (L2)}
Bei den folgenden Gleichungen handelt es sich um die aus dem ersten Protokoll modellierten Systemgleichungen des Helikopters: 

\begin{equation}\label{eq:alpha}
    \ddot{\alpha} = \frac{-(F_{\mathrm{vorne}} + F_{\mathrm{hinten}})  l_{\mathrm{heli}}  \sin(\gamma)}{I_{\alpha}}
\end{equation}

\begin{equation}\label{eq:beta}
    \ddot{\beta} = \frac{(F_{\mathrm{vorne}} + F_{\mathrm{hinten}})  l_{\mathrm{heli}}  \cos(\gamma) - F_{\mathrm{g}}  l_{mmp}  \cos(\beta)}{I_{\beta}}
\end{equation}

\begin{equation}\label{eq:gamma}
\ddot{\gamma} = \frac{(F_{\mathrm{vorne}} - F_{\mathrm{hinten}})  l_{rotor}}{I_{\gamma}}
\end{equation}

Mit
\begin{equation}
F_{\mathrm{g}} = m_{\mathrm{mmp}}g
\label{eq:F_g}
\end{equation}

Wie bereits in Protkoll 1 beschrieben, fehlen nur wenigeWerte zur vollständigen Systemidentifikation. Hier macht sich nun der große Vorteil der CAD Modelle zu Nutzen,
da keinerleich Trägheitstensoren oder Gesamtmassen bestimmt werden müssen. Diese können direkt aus dem CAD Modell entnommen werden. Dies ist äußerst hilfreich, da die experimentelle Bestimmung der Trägheitstensoren sowohl aufwändig als auch fehleranfällig ist. Die Trägheitstensoren
wurden hierbei um den gewählten Linearisierungspunkt bestimmt. Dabei ist ebenfalls anzumerken, dass sich die Trägheitstensoren mit anderen Winkeln leicht ändern
können, aber aufgrund des geringen Einflusses im Folgenden als konstant angenommen werden. Ebenfalls wird davon ausgegangen, dass das Modell auch in seiner bereits
Vereinfachten Form bereits eine gute Systembeschreibung des realen Systems darstellt.

Die einzigen zu bestimmenden Systemparameter sind somit die Spannung-Kraft Kennlinien $F_{\mathrm{vorne}}$ und $F_{\mathrm{hinten}}$ der Rotoren. 
Dafür wurde der reale Helikopter auf \(\beta = 0\) fixiert. Die einzelnen Rotoren wurden nun einzeln geprüft, da davon auszugehen ist, dass die Rotoren unterschiedliche Kennlinien liefern könnten. 
Die Rotor-Einheit wurde nun von unten auf eine Waage gelegt und von oben mit einem Gewicht beschwert. Nun wurden verschiedene Spannungslevel angelegt und die jeweilige Differenz der Waage abgelesen.
Mit dieser Methode konnte demnach über die Differenz der Gewichtskraft ein Rückschluss auf die durch den Rotor erzeugte Auftriebskraft gezogen werden.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.9\columnwidth]{Heli_skizze.png}
    \caption{Motorkennlinie invertiert}
    \label{fig:heliSkizze}
\end{figure}

\begin{equation}
F = m g
\end{equation}
Dabei ist $g = 9.81\,\mathrm{m/s^2}$ die Gewichtskraft.
Die so erhaltenen Messwerte wurden in Matlab ausgewertet und eine lineare Regression durchgeführt, um die Spannung-Kraft Kennlinie zu bestimmen.
Die so erhaltene Motorkennlinie ist in Abbildung \ref{fig:Motorkennlinie} dargestellt.
\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.9\columnwidth]{Motorkennlinie_1.jpg}
    \caption{Motorkennlinie}
    \label{fig:Motorkennlinie}
\end{figure}

Die erhaltene Motorkennlinie wird hierbei aufgrund sehr ähnlicher Messwerte, welche in der Abbildung
\ref{fig:Motorkennlinie} in Grün (Rotor vorne) und Rot (Rotor hinten) dargestellt sind für beide Rotoren gleich angenommen.
Um daraus eine Kennlinie bestimmen zu können, werden hierbei die jeweiligen Mittelwerte der Messungen berechnet, was ebenfalls Messungenauigkeiten der Waage und die unterschiedliche Positionierung des Rotors auf der Waage kompensiert.
Mit Hilfe der $polyfit$ Funktion in Matlab kann schließlich das Polynom 3. Ordnung bestimmt werden:
\begin{equation}
F_{\mathrm{Rotor}} = 0.000499 U^3 - 0.002815 U^2 + 0.0315 U -0.0210
\end{equation}

Da im späteren Verlauf des Praktikums der Regler allerdings mit Kräften arbeitet und der Versuchsstand mit einer Spannung angesteuert wird, muss die Kennlinie invertiert werden.
Da das invertieren eines Polynoms 3. Ordnung analytisch sehr aufwändig, bis unmöglich ist, wurde dies durch eine erneute Polynomapproximation 3. Ordnung durchgeführt.
Die daraus gewonnene invertierte Motorkennlinie ist in Abbildung \ref{fig:Motorkennlinie_inv} dargestellt.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.9\columnwidth]{Motorkennlinie_2.jpg}
    \caption{Motorkennlinie invertiert}
    \label{fig:Motorkennlinie_inv}
\end{figure}

und wird durch das Polynom
\begin{equation}
U_{\mathrm{Rotor}} = 24.047576 F^3 -45.530359 F^2 + 34.5412 F 1.0596
\end{equation}
beschrieben. 

Die Ungenauigkeiten, welche in der Kraftmessung zu sehen sind werden jedoch im Folgenden durch den Regler kompensiert und führen aufgrund eines Integratoranteils im Reglerverhalten zu keinen bleibenden Regelabweichungen.
Damit wurden sind nun alle Systemparameter bekannt und das Modell kann im folgenden auf Simulink implementiert und simulativ validiert werden.
Darauf wird in folgenden eingegangen.


\section{Zweite Hausaufgabe (H2)}

Wie bereits in Protokoll 1 diskutiert, handelt es sich bereits um ein stark vereinfachtes Modell des Helikopters. Da die Auswirkung des Winkels $\beta$ auf die Beschleunigung $\ddot{\alpha}$ vernachlässigt wird,
muss im stetig in Betracht gezogen werden, diese Modellrekuktion anzupassen, sobald sich diese Vernachlässigung als problematisch herausstellt. 

Zunächst wurden nun die nichtlinearen Systemgleichungen \eqref{eq:alpha}--\eqref{eq:gamma} wie in Abb. \ref{fig:Simulink_Bewegungsgleichungen} in Simulink implementiert.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.9\columnwidth]{Simulink_Bewegungsgleichungen.png}
    \caption{Bewegungsgleichungen implementiert in Simulink}
    \label{fig:Simulink_Bewegungsgleichungen}
\end{figure}

Die Bewegungsgleichungen wurden hierbei in einem Matlab Function Block implementiert. Dieser Block erhält dabei die beiden Eingangskräfte der Rotoren
$F_{\mathrm{vorne}}$ und $F_{\mathrm{hinten}}$ sowie die aktuellen Winkel $\beta$ und $\gamma$ als Eingangsgrößen. Durch Doppelintegratoren, werden die berechneten Winkelbeschleunigungen in ihre jeweiligen Positionen 
umgewandelt, welche zur erneuten Berechnung der Winkelbeschleunigungen benötigt werden.

Um das Modell zu validieren, wurden Testszenarien erstellt, in welchen die Eingangsgrößen, als auch die Anfangsbedingungen der Integratoren variiert wurden.
Die so erhaltenen Simulationsergebnisse wurden anschließend durch anliegende Scopes an den Ausgängen Analysiert und auf ihre physikalische Korrektheit überprüft.

Des Weiteren wurden nun die Gleichungen linearisiert, und direkt in Zustandsraum gebracht. Im Folgenden werden folgende Konventionen definiert:
\begin{equation}
    x = \begin{bmatrix} \alpha & \beta & \gamma & \dot{\alpha} & \dot{\beta} & \dot{\gamma} \end{bmatrix}^T
\end{equation}
\begin{equation}
    u = \begin{bmatrix} U_{\mathrm{vorne}} & U_{\mathrm{hinten}} \end{bmatrix}^T
\end{equation}
\begin{equation}
    y = \begin{bmatrix} \alpha & \beta & \gamma \end{bmatrix}^T
\end{equation}
Mit diesen Definitionen ergeben sich die folgenden Zustandsraumdarstellungen:
\begin{equation}
    \Delta\dot{x} = A \Delta x + B \Delta u
\end{equation}
\begin{equation}
    \Delta y = C \Delta x + D \Delta u
\end{equation}
Mit den Matritzen ergeben sich aus der Linearisierung der Systemgleichungen \eqref{eq:alpha} \eqref{eq:beta} \eqref{eq:gamma}:
\begin{equation}\label{eq_alpha_x}
    \frac{\partial \ddot{\alpha}}{\partial x} = 
    \begin{bmatrix}
    0 & 0 & -C_1 \cos(\gamma) P & 0 & 0 & 0
    \end{bmatrix}
\end{equation}
\begin{equation}\label{eq_beta_x}
    \frac{\partial \ddot{\beta}}{\partial x} = 
    \begin{bmatrix}
    0 & C_2 \sin(\beta) & -C_3 \sin(\gamma) P & 0 & 0 & 0
    \end{bmatrix}
\end{equation}
\begin{equation}\label{eq_gamma_x}
    \frac{\partial \ddot{\gamma}}{\partial x} = 
    \begin{bmatrix}
    0 & 0 & 0 & 0 & 0 & 0
    \end{bmatrix}
\end{equation}
mit 
\begin{equation}
P = \frac{131 F_{\mathrm{hinten}}}{200} + \frac{131 F_{\mathrm{vorne}}}{200}
\end{equation}
und $$C_1 =  0.884185$$ $$C_2 = 0.346278$$ $$C_3 = 0.888798$$\\
sowie:
\begin{equation}\label{eq_alpha_u}
    \frac{\partial \ddot{\alpha}}{\partial u} = 
    \begin{bmatrix}
    -C_4 \sin(\gamma) & -C_4 \sin(\gamma)
    \end{bmatrix}
\end{equation}
\begin{equation}\label{eq_beta_u}
    \frac{\partial \ddot{\beta}}{\partial u} = 
    \begin{bmatrix}
    C_5 \cos(\gamma) & C_5 \cos(\gamma)
    \end{bmatrix}
\end{equation}
\begin{equation}\label{eq_gamma_u}
    \frac{\partial \ddot{\gamma}}{\partial u} = 
    \begin{bmatrix}
    C_6 & -C_6
    \end{bmatrix}
\end{equation}
und $$C_4 = 0.579141$$ $$C_5 = 0.582163$$ $$C_6 = 4.41224$$\\

Für die Zustandsraumdarstellung und den Arbeitspunt $x_0 = \begin{bmatrix} 0 & -11^\circ & 0 & 0 & 0 & 0 \end{bmatrix}^T$ und $u_0 = \begin{bmatrix} 0.5 & 0.5 \end{bmatrix}^T$ folgen die
Matritzen A, B, C und D. Wobei hier die physikalischen
Gegebenheiten schnell zu erkennen sind. Unter anderem
ist zu erkennen, dass in C die Positionen direkt messbar
sind, während für die Geschwindigkeiten keine Sensoren
vorhanden sind. Ebenfalls ist in D zu erkennen, dass kein
direkter Durchgriff durch die Eingangsgrößen möglich ist.
\begin{equation}
A = 
\begin{bmatrix}
0 & 0 & 0 & 1 & 0 & 0 \\
0 & 0 & 0 & 0 & 1 & 0 \\
0 & 0 & 0 & 0 & 0 & 1 \\
0 & 0 & -C_7 & 0 & 0 & 0 \\
0 & -C_8 \sin\left(\frac{11\pi}{180}\right) & 0 & 0 & 0 & 0 \\
0 & 0 & 0 & 0 & 0 & 0
\end{bmatrix}
\end{equation}
\begin{equation}
B = 
\begin{bmatrix}
0 & 0 \\
0 & 0 \\
0 & 0 \\
0 & 0 \\
C_9 & C_9 \\
C_{10} & -C_{10}
\end{bmatrix}
\end{equation}
\begin{equation}
    C = 
\begin{bmatrix}
1 & 0 & 0 & 0 & 0 & 0 \\
0 & 1 & 0 & 0 & 0 & 0 \\
0 & 0 & 1 & 0 & 0 & 0
\end{bmatrix}
\end{equation}
\begin{equation}
    D =
\begin{bmatrix}
0 & 0 \\
0 & 0 \\
0 & 0
\end{bmatrix}
\end{equation}
wobei
\begin{equation}
C_7 = 0.579141
\end{equation}
\begin{equation}
C_8 = 0.346278
\end{equation}
\begin{equation}
C_9 = 0.582163
\end{equation}
\begin{equation}
C_{10} = 4.41224
\end{equation}



Als Arbeitspunkt wurde wie oben beschrieben $x_0 = \begin{bmatrix} 0 & -11^\circ & 0 & 0 & 0 & 0 \end{bmatrix}^T$  gewählt, da dies den Mittelpunkt unseres Arbeitsbereiches entspricht.
Um einen stationären Flugzustand des Helikopters zu erreichen, wurden mit Hilfe der Bewegungsgleichungen unter der Vorgabe des Arbeitspunktes der Input $u_0 = \begin{bmatrix} 0.5 & 0.5 \end{bmatrix}^T$ bestimmt.
Es ist wichtig zu beachten, dass lediglich die Winkel $\beta$ und $\gamma$ in die Linearisierung eingehen. Eine Änderung des Winkels $\alpha$ sowie der Winkelgeschwindigkeiten $\dot{\alpha}$, $\dot{\beta}$ und $\dot{\gamma}$ hat keinen Einfluss auf die Linearisierung, da diese auch in den nichtlinearen Gleichungen \eqref{eq:alpha} \eqref{eq:beta} \eqref{eq:gamma} nicht vorkommen.\\
Die Wahl gewählten Arbeitspunktes birgt jedoch auch risiken. Durch die Wahl von $\gamma = 0$ 
fallen viele Terme der Linearisierung, in welchen $\gamma$ als $\sin(\gamma)$ eingeht, weg (vgl. Gleichungen \eqref{eq_beta_x} und \eqref{eq_alpha_u}).
Dies kann dazu führen, dass das linearisierte System andere Eigenschaften aufweist als das nichtlineare System. 
Daher muss dies im späteren Regelerentwurf berücksichtigt werden und gegebenenfalls eine Anpassung des Arbeitspunktes vorgenommen werden. Eine weitere Möglichkeit wäre, den Arbeitpunkt für unterschiedliche Flugmanöver anzupassen, um so die Auswirkungen der Linearisierung zu minimieren und diese besser an das reale Flugverhalten anzupassen.

Die Darstellung in Zustandsraum ist essentiell, da sie sowohl die 
Grundlage für den späteren linearen Regelerentwurf darstellt, als auch Systemtheoretische Eigenschaften des Systems aufzeigt.
Die Systempole des linearen Systems liegen bei:
$$\lambda_{1,2,3,4} = 0, \quad \lambda_{5,6} = \pm 0.2570i$$\\
Dies zeigt, dass das System rein marginal stabil ist. Jedoch wurde auch hier eine Ruhelage gewählt, wobei bei kleinen änderungen der Eingangsgröße $u$ das System instabil werden kann.
Dies ist auch physikalisch nachvollziehbar, da der Helikopter ohne Regler in der Ruhelage ebenfalls marginal stabil ist. Kleine Störungen führen dazu, dass der Helikopter aus seiner Ruhelage ausweicht und nicht von alleine wieder in die Ruhelage zurückkehrt.
Da das für dieses System sowohl die Steuerbarkeitsmatrix
\begin{equation}
\mathcal{S} = \begin{bmatrix} B & AB & A^2B & ... & A^{n-1}B \end{bmatrix}
\end{equation}
als auch die Beobachtbarkeitsmatrix
\begin{equation}
\mathcal{O} = \begin{bmatrix} C \\ CA \\ CA^2 \\ ... \\ CA^{n-1} \end{bmatrix}
\end{equation}
den vollen Rang besitzen, ist das System sowohl vollständig steuer- als auch beobachtbar. Dies bildet die Grundlage für den späteren Reglerentwurf

\section{Kommentare und Ausblick auf L3}
Obwohl aufgrund von ungenauen Messwerkzeugen nur eine grobe Abschätzung der Motorkennlinie möglich war, konnte dennoch eine plausible Kennlinie bestimmt werden. 

Im Ausblick auf den nächsten Labortag (L3) wird nun der Reglerentwurf anhand des linearisierten Modells erfolgen. Wird hierfür ein Zustandsregler verwendet, so muss hierfür 
noch ein geeigneter Zustandsbeobachter entworfen werden, da nicht alle Zustände des Systems messbar sind. Ebenfalls wird es in Betracht gezogen, die Regelstruktur durch eine Vorsteuerung zu ergänzen.
Im Anschluss darauf werden passende Parameter für den Regler, als auch für den Beobachter gesucht.


\end{document}


