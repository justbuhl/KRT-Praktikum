\documentclass{ifacconf}

\usepackage{natbib}            % you should have natbib.sty
\usepackage[utf8]{inputenc}    % Eingabe von Umlauten im Editor, dieser sollte dann auch auf utf8 Encoding eingestellt sein
\usepackage{graphicx}          % Include this line if your 
                               % document contains figures,
%\usepackage[dvips]{epsfig}    % or this line, depending on which
                               % you prefer.
                               
\usepackage{units}

% for German
% \usepackage{ngerman}           % neue Deutsche Rechtschreibung, Silbentrennung
% \usepackage[T1]{fontenc}       % Trennung mit Umlauten

% to include tikz pictures of figure created with matlab2tikz, see also file ``plotFigureTest.m''
\usepackage{tikz}
\usepackage{pgfplots}
\pgfplotsset{compat=newest}  % use newest version of pgfplots
\usepackage{amsmath}  % useful for math

% to include the legend into the caption. The commands are
%\mlLineLegend{red}
%\mlLineLegendDashed{red}
%\mlLineLegendDotted{red}
%\mlLineLegendDashDotted{red}
%\mlPointLegend{red}
\newlength{\mlLegendThickness}
\setlength{\mlLegendThickness}{0.4mm}
\newlength{\mlLegendHeight}
\setlength{\mlLegendHeight}{0.6ex}
\newcommand{\mlLineLegend}[1]{\mbox{\color{#1}
\protect\rule[\mlLegendHeight]{3mm}{\mlLegendThickness}\hspace*{-1mm}
}}
\newcommand{\mlLineLegendDashed}[1]{\mbox{\color{#1}
\protect\rule[\mlLegendHeight]{1.5mm}{\mlLegendThickness}\hspace*{0mm}
\protect\rule[\mlLegendHeight]{1.5mm}{\mlLegendThickness}\hspace*{-1mm}
}}
\newcommand{\mlLineLegendDotted}[1]{\mbox{\color{#1}
\protect\rule[\mlLegendHeight]{0.4mm}{\mlLegendThickness}\hspace*{0mm}
\protect\rule[\mlLegendHeight]{0.4mm}{\mlLegendThickness}\hspace*{0mm}
\protect\rule[\mlLegendHeight]{0.4mm}{\mlLegendThickness}\hspace*{0mm}
\protect\rule[\mlLegendHeight]{0.4mm}{\mlLegendThickness}\hspace*{-1mm}
}}
\newcommand{\mlLineLegendDashDotted}[1]{\mbox{\color{#1}
\protect\rule[\mlLegendHeight]{1.5mm}{\mlLegendThickness}\hspace*{0mm}
\protect\rule[\mlLegendHeight]{0.4mm}{\mlLegendThickness}\hspace*{0mm}
\protect\rule[\mlLegendHeight]{1.5mm}{\mlLegendThickness}\hspace*{0mm}
\protect\rule[\mlLegendHeight]{0.4mm}{\mlLegendThickness}\hspace*{-1mm}
}}
\newcommand{\mlPointLegend}[1]{\mbox{\color{#1}
\protect\rule[\mlLegendHeight]{0.4mm}{\mlLegendThickness}\hspace*{-0.75mm}
}}

\begin{document}

\begin{frontmatter}

\title{KRT Praktikum: Protokoll 5 - Abschlussprotokoll}

\thanks[footnoteinfo]{Institute for Systems Theory and Automatic Control, University of Stuttgart, Germany. \textit{http://www.ist.uni-stuttgart.de}}

% include all authors, underline corresponding author
\author{Kimon Beyer, Yves Gaßmann, Justin Buhl} 
% \author{}

\begin{abstract}        
Dieses Protokoll dokumentiert die Ergebnisse und Erkenntnisse des KRT Praktikums am IST. Im Rahmen des Praktikums wurden verschiedene Methoden zur Regelung und Trajektoriengenerierung für ein Modell eines Quadrokopters untersucht und implementiert.
Dabei wird auf das mit Hilfe von CAD erstellte Modell des Quadrokopters eingegangen, sowie die anschließende Systemanalyse und Reglerentwurf betrachtet. Dabei
wurde zunächst ein LQR Reglerentwurf durchgeführt, wobei dieses zu einem LQI mit anschließender Vorsteuerung erweitert worden ist. 
Die abschließende Aufgabe wurde mit Hilfe einer Trajektoriengenerierung umgesetzt, wobei zwei Ansätze präsentiert werden: 
Diskretisierung und Lösung eines Optimalsteuerungsproblems.
% Abstract of not more than 250 words.
\end{abstract}


\end{frontmatter}

\section{Einleitung}


\section{Modellierung}

\section{Reglerentwurf}
Für den Reglerentwurf wurde das aus Protokoll 2 gewonnene lineare Helikoptermodell genutzt. Wichtig ist hierbei zu beachten,
dass der Reglerentwurf auf dem linearen Modell basiert und somit bei der Implementierung auf das nichtlineare Modell noch der 
Arbeitspunkt bzw. Linearisierungspunkt entsprechend verrechnet werden muss. 
Die Zustände sind zur Erinnerung wie folgt definiert:
\begin{equation}
    x = \begin{bmatrix} \alpha & \beta & \gamma & \dot{\alpha} & \dot{\beta} & \dot{\gamma} \end{bmatrix}^T
\end{equation}
\begin{equation}
    u = \begin{bmatrix} U_{\mathrm{vorne}} & U_{\mathrm{hinten}} \end{bmatrix}^T
\end{equation}
\begin{equation}
    y = \begin{bmatrix} \alpha & \beta & \gamma \end{bmatrix}^T
\end{equation}

Der geschlossene Regelkreis mit Zustandsrückführung ergibt sich unter Berücksichtigung der Linearisierung um den Arbeitspunkt $(x_0, u_0)$ zu:
\begin{equation}
\Delta u = -K\,\Delta x,\qquad \Delta x = x - x_0,\qquad \Delta u = u - u_0.
\end{equation}
Hierbei bezeichnet $K$ die Reglermatrix, während $x_0$ und $u_0$ den stationären Arbeitspunkt des Systems charakterisieren. 

Zur Implementierung und Erprobung unseres Regelungsentwurfs wurde nun das CAD-Modell, das bereits zur Modellierung verwendet wurde, in 
Matlab Simulink als ein Simscape Modell exportiert.
An diesem Modell wurden dann die Regelungsalgorithmen implementiert und getestet, bevor es an den realen Versuchsstand ging.

\subsection{Reglerentwurf}

Da das System mehrere Input und Outputs verfügt und somit ein MIMO System vorliegt, wurde sich dazu entschieden, einen LQ-Regler zu entwerfen. Die Vorteile dieses Verfahrens wurden bereits in Protokoll 2 erläutert.

Da es sich bei einem LQ-Regler um einen Zustandsregler handelt wird für die Regelung sowohl die\\ Winkelgeschwindigkeiten $\dot{\alpha}$, $\dot{\beta}$ und $\dot{\gamma}$ als auch die  Winkel $\alpha$, $\beta$ und $\gamma$ benötigt. Da die Encoder nur die Winkel messen, wurde ein Luenberger-Beobachter implementiert, damit die Geschwindigkeiten geschätzt werden können. 

\begin{equation}
\Delta\dot{\hat{x}} = A\,\Delta\hat{x} + B\,\Delta\hat{u} + L\big(\Delta y - \Delta\hat{y}\big),
\end{equation}
mit
\begin{equation}
\Delta\hat{y} = C\,\Delta\hat{x},
\end{equation}
und der Schätzfehler $\hat{e}=\Delta x-\Delta\hat{x}$ erfüllt
\begin{equation}
\dot{\hat{e}}=(A-LC)\,\hat{e}.
\end{equation}

Zur Stabilität und schnellen Konvergenz wurden die Beobachterpole (Eigenwerte von $A-LC$) deutlich schneller als die Reglerpole (z.\,B. Faktor 5–10) gewählt. Die Beobachtermatrix $L$ wurde in MATLAB durch Polvorgabe bestimmt.


\subsubsection{LQR-Entwurf}
Der Vorteil des LQR in der vergleichsweise einfachen Implementierung sowie den guten Regelungseigenschaften hat sich im Praktikumsversuch bestätigt. Obwohl die Robustheitseigenschaften durch die Nutzung eines Beobachters nicht mehr gegeben sind, 
hat der Versuchsstand ein zufriedenstellendes Verhalten gezeigt. 
Des Weiteren wurde überlegt, eine Vorsteuerung einzubauen, indem bei der Zustandsrückführung die Referenzwerte für die Zustände aus der Trajektoriengenerierung vorgegeben werden. Das heist, in den LQI Regler werden letztendlich nicht die Zustände geführt, sonder der Regelfehler bezüglich der vorgegebenen Referenz. Dies wies sich jedoch als verschlechternd heraus, wodurch dieses Konzept der Vorsteuerung wieder verworfen worden ist. 

Dennoch hat sich herausgestellt, dass die bleibende 
Regelabweichung durch die fehlenden Integratorterme ein Problem darstellt, da sich die Abweichung in den Zuständen als zu
groß darstellt, um die geforderten Anforderungen zu erfüllen. Daher wurde der LQR auf zwei Integratorzustände erweitert.

\subsubsection{LQI-Entwurf}
Wie bereits erwähnt, stellt der LQI-Regler eine Erweiterung des LQR-Reglers dar. Die Erweiterung geschieht hierbei durch 
Hinzunahme von sogenannten Integratorzuständen für diejenigen Größen, für die die bleibende Regelabweichung eliminiert werden soll. Zu beachten ist jedoch,
dass durch die Nutzung von Integratoren auf jeden Fall darauf geachtet werden muss, ein Aufschwingen des Integrators zu vermeiden wodurch ein Anti-Windup implementiert worden ist.
Dadurch ergab sich ein erweiterter Zustandsraum, der wie folgt aussieht:
\begin{equation}
    x = \begin{bmatrix} \alpha & \beta & \gamma & \dot{\alpha} & \dot{\beta} & \dot{\gamma} & \xi_1 & \xi_2 \end{bmatrix}^T
\end{equation}

wobei $\xi_1$ und $\xi_2$ die Integratorzustände für die Winkel $\alpha$ und $\beta$ darstellen und folgendermaßen im Zustandsraum gebildet werden:

\begin{equation}
    \xi_1 = \xi_{1,\mathrm{ref}} - \int (\alpha_{\mathrm{ref}} - \alpha)\,\mathrm{d}t
\end{equation}
\begin{equation}
    \xi_2 = \xi_{2,\mathrm{ref}} - \int (\beta_{\mathrm{ref}} - \beta)\,\mathrm{d}t
\end{equation}

wobei $\xi_{1,\mathrm{ref}} = 0$ und $\xi_{2,\mathrm{ref}} = 0$.

Für den Winkel $\gamma$ wird kein Integratorzustand hinzugefügt, da dieser Winkel lediglich zum Verändern des $\beta$-Winkels genutzt wird und keine genaue Regelung des $\gamma$-Winkels erforderlich ist.

Für die Wahl der Gewichtungsmatrizen $Q$ und $R$ hat sich folgende Wahl als zufriedenstellend ergeben, mit der auch die Ergebnisse in Abschnitt~\ref{sec:Ergebnisse} erzielt worden sind. Dabei ist noch zu erwähnen, dass für die Nutzung des Optimalsteuerungsproblems (OSP) als 
Trajektoriengenerierung die Gewichtungsmatrizen leicht angepasst worden sind. Dabei steht D für Diskretisierung (Trajektoriengenerierung).

\begin{equation}
\begin{split}
Q_{D} = \operatorname{diag}\big(&5,\;2,\;1,\;0,001,\\
 &0,001,\;7,\;30,\;10\big)
\end{split}
\end{equation}
\begin{equation}
R_{D} = \operatorname{diag}\big(2,\;2\big)
\end{equation} 

Dabei wurde für die Nutzung des OSP als Trajektorie lediglich der erste Integratoreintrag der Q Gewichtungsmatrix von 30 auf 100 erhöht. Alle anderen Werte, sowie die R Gewichtungsmatrix blieben unverändert.
Hierbei wurden die Gewichtungen für die Winkel $\alpha$ und $\beta$ sowie für die Integratorzustände $\xi_1$ und $\xi_2$ deutlich höher gewählt als für die Winkelgeschwindigkeiten und den Winkel $\gamma$. Dies hat den Hintergund, dass eine genaue Regelung der Winkel $\alpha$ und $\beta$ sowie die Eliminierung der bleibenden Regelabweichung für diese Winkel von hoher Wichtigkeit sind. Die Winkelgeschwindigkeiten und der Winkel $\gamma$ sind weniger wichtig für die Regelungsaufgabe, weshalb diese mit geringeren Gewichtungen versehen wurden. Zusätzlich sorgt eine gute Regelung von $\alpha$ und $\beta$ auch für eine gute Regelung von $\gamma$, da dieser Winkel nur zur Unterstützung der Regelung von $\beta$ dient. Die Wahl der Gewichtungsmatrizen wurde dabei am realen versuchsstand iterativ bestimmt. Es hat sich nämlich herausgestellt, dass es durchaus Abweichungen zur Simulation gibt, wodurch die Reglerparameter angepasst werden mussten. Mit der Wahl dieser Gewichtungsmatrizen ergeben sich folgende Regler und Beobachtungspole:

\begin{equation}
\mathrm{Reglerpole}_{\mathrm{LQI}} =
\begin{bmatrix}
 -0.3729 + 0.8393\mathrm{i} \\
  -0.3729 - 0.8393\mathrm{i} \\
  -0.6647 + 1.0791\mathrm{i} \\
  -0.6647 - 1.0791\mathrm{i} \\
  -0.8632 + 0.3290\mathrm{i} \\
  -0.8632 - 0.3290\mathrm{i} \\
  -1.1460 + 0.0000\mathrm{i} \\  
 -11.6676 + 0.0000\mathrm{i} \\
\end{bmatrix}
\end{equation}

\begin{equation}
\text{Beobachterpole} =
\begin{bmatrix}
-6 + 0.0000\mathrm{i}\\
-6.1 + 0.0000\mathrm{i}\\
-6.2 + 0.0000\mathrm{i}\\
-6.3 + 0.0000\mathrm{i}\\
-6.4 + 0.0000\mathrm{i}\\
-6.5 + 0.0000\mathrm{i}
\end{bmatrix}
\end{equation}

\subsection{Regler mit Optimalsteuerungsproblem}
Da zur Trajektoriengenerierung ebenfalls ein Optimalsteuerungsproblem gelöst worden ist, konnte die Reglerstruktur zu einer 
2-DOF-Struktur erweitert werden. Dies bedeutet, dass die aus dem Optimalsteuerungsproblem berechnete Stellgröße 
$u_{OSP}$ auf der Reglerausgang $u_{LQI}$ addiert worden ist. Des Weiteren berechnete das OSP noch die Referenzzustände, die 
genutzt worden sind, um die Vorsteuerung zu implementieren, indem von diesen Referenzzuständen noch die gemessenen Zustände abgezogen worden sind und diese Regelabweichung in den LQI Regler geführt worden ist. 


\section{Trajektoriengenerierung}

\section{Ergebnisse}
\label{sec:Ergebnisse}

\section{Schlussfolgerungen und Fazit}


\end{document}